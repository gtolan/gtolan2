document.addEventListener('DOMContentLoaded', function(){

var criticalRenderBlog = document.getElementById('criticalRenderBlog');

var mainImageCRP = document.createElement('IMG');
    mainImageCRP.src = 'images/renderpath.png';
    mainImageCRP.classList.add('blog-image');
    criticalRenderBlog.appendChild(mainImageCRP);


var criticalRender = document.createElement('DIV');
var para = document.createElement('p');
para.innerHTML = "<hr><b>Understand the flow</b><br><br>&#x2606; The critical render path is the flow of data that it takes to render a page for the user.  Some of this data can be render blocking, and some may be run asynchronous. Therefore given a set of rules, we can organise this data to relay the page faster for the user.<br><br>Every developer knows that every millisecond counts in the first load of any page. The critical render path analysis is the process assessment behind making this intention a reality.<br><br>The image above follows the steps of the render path.<br>In order to construct the render tree, the browser will complete the following steps:<br><br><p class='blogPadding'>1. Traverse through the DOM tree.</p><p class='blogPadding'>2. Find the CSSOM matching properties and apply them to the node.</p><p class='blogPadding'>3. Emit visible nodes and their styles *no (display:none elements)</p><br>This will provide the browser with a render tree.  The render tree is a snapshot of box-shaped elements - without any device related sizes or positioning.<br><br>Now the browser must:<br><br><p class='blogPadding'>4. Run the remaining page layout and element resizing</p><br><br>The element style property information will normally rely on the page viewport. Using these values the browser can calculate the intended size and positioning of elements for the device.<br><br><br><p class='blogPadding'>5. The browser is be ready to start painting the page for the user.</p><br><br>This seems simple and obvious to some, but it still comes with a lot of organisational issues that can arise and slow down a page. When dealing with large projects there are always going to be performance issues.<br><br>The process of analysing the render construct will help to improve the performance of any page.<br><br><br><hr><br><br><b>Optimisation Tips</b><br><br>Now that we understand the flow, we apply best practice rules to achieve the fastest page render possible.<br><br>There are three main pillars developers can use to gain speed in the critical render path. They are:<br><br><p class='blogPadding'>1. Compress - This means html, js ,css, images and media files, gzip text files etc.<br></p><p class='blogPadding'>2. Cache - cache resources that will not change regularly<br></p><p class='blogPadding'>3. Reduce render blocking resources - We can implement async for some resources as well as deferring scripts/cdns we do not need immediately.<br></p><br><br>In implementing these pillars we will find that we will reduce the number of bytes needed to download the page.<br><br> So what is the best way to get started with all of this information?Below I have provided a summary of steps  you can use to achieve this.<br><br><b><a href='https://developers.google.com/speed/pagespeed/insights/'>&#x1f517; Google page speed insights</a></b> - clear direct suggestions to improve pages speed. Such as - compression, render blocking, device  performance rating<br><br><p class='blogPadding'>1. View your live page render waterfall.</p><br><br><b><a href='https://www.webpagetest.org/'>&#x1f517; WebpageTest.org</b></a> - provides an analysis of render and load times for up to three visits. Review your waterfall and resources here. Remember we want a live view to get real life results.<br><br><img class='blog-image' src='images/waterfall.png'><br><p class='blogPadding'>2. Check the organisation of resources in the page waterfall-</p><br><br>Move any resource futher down the html page if it is not necessary for the first render. Load images dynamically with javascript if they are embedded in html that will slow the first render<br><br>Make a note of the first render and completed page times provided by <a href='https://www.webpagetest.org/'>&#x1f517; WebpageTest.org</b></a><br><br>Then make a note of how many resources are loaded before the first page render. Make sure these resources are completely necessary at this position in the html<br><br><br><p class='blogPadding'>3. Check values of compressed images - </p><br><br><img class='blog-image small' src='images/imageopt.png'><br><p class='blogPadding'>4. Reduce render blocking CSS </p><br><br>CSS and HTML are by nature render blocking. This can be used as a benefit to our page load. If we have a css file for the first render of the page. We can reduce the amount of compiling the browser needs to render. The remaining css can be loaded when it is needed.<br><br>Using pwa methodology we could take this further and only load the toolbar and footer with a central loaderGif using only inline css - then dynamically load the main body of the page. This would result in the instant view of the toolbar footer and loading gif as the rest of the page renders.<br><br>Css can also be separated into media query and orientation properties to reduce necessary render blocking css.<br><br><p class='blogPadding'>5. Check for render blocking scripts.</p><br><br>For certain scripts we may be able to apply asynchronous loading where possible - such as anayltics. Review scripts and check which can be deferred and which can be loaded async.<br><br>The defer script attribute will allow the script to be loaded at the end of the page load. The async attribute will allow script to load asynchronous and lets the script run in the background while the document is being parsed<br><br><img class='blog-image small' src='images/deferasync.png'><br><br>After we have followed these steps, we should find that our page will load significantly faster. Page Speed insights and Lighthouse should rate your page over 90/100 at the very least.<br><br>WebPageSpeedTest should provide 5 A ratings and show a render time of less than 1600ms.<br>This is the standard that has been set for users in recent years. Many pages will not load in under 2/3s. This provides a significant benefit for developers that spend time on the critical render path. When we know that users are more likely to bounce from a slower loaded page. <br><br> There are many tools and methods a developer can use, but optimisation of page render is a paramount task for all frontend developers.<br><br> With consumer demand for faster apps and webpages increasing all the time, we must strive to be better than what the consumer expects";
   

 

criticalRender.appendChild(para);


criticalRenderBlog.appendChild(criticalRender);



var dragndropBlog = document.getElementById('dragndropBlog');
    
var mainImageDND = document.createElement('IMG');
    mainImageDND.src = 'images/dragnDrop.png';
    mainImageDND.classList.add('blog-image');
    dragndropBlog.appendChild(mainImageDND);

    
var dragndropContainer = document.createElement('DIV');
var paraDragDrop = document.createElement('p');
paraDragDrop.innerHTML = "<hr>Drag and drop is cool isn’t it?<br>Well on some devices it can be out of the box fantastic. On others we can back it up with libraries or fallbacks. But in short, it is fun and that means great user experience.<br><br>Check out my example drag and drop on delkopro.co.uk<br>For desktop devices you should be able to see a drag and drop bin system for deleting options, similar to on apple and android devices.<br><br>In my latest example I chose to add my own fallback for mobile devices. This was helped by animation and javascript.<br><br>A great example of drag and drop can be seen in the el corte ingles shopping app. This app allows you to drag from the shelves into your shopping basket. I previously worked on a 3d version of this in blender for fun.<br><br>Here are the simple steps to getting started with html5 drag and drop:<br><br>Identify what elements you want to be draggable.<p class='blogPadding'>Define the drag elements information</p><p class='blogPadding'>Apply a drag image for the element</p><p class='blogPadding'>Apply a drag effect for the element</p><p class='blogPadding'>Define the drop zone for the element</p><p class='blogPadding'>Handle the drop effect</p><p class='blogPadding'>Stop the drag process - whether or not successful.* can check.</p>";

dragndropContainer.appendChild(paraDragDrop);
dragndropBlog.appendChild(dragndropContainer);



var fluidfontBlog = document.getElementById('fluidfontBlog');
 
var mainImageFF = document.createElement('IMG');
    mainImageFF.src = 'images/fluidGif.gif';
    mainImageFF.classList.add('blog-image');
    fluidfontBlog.appendChild(mainImageFF);

    
var fluidfontContainer = document.createElement('DIV');
var parafluidfont = document.createElement('p');
parafluidfont.innerHTML = "<hr>&#x2606; Fluid Font Scaling refers to font that will change size fluidly based on parameters set by the device properties. This means we can set font sizes based on the device size that adjust smoothly with an elastic rendering rather than a snapping render.<br><br>Traditional font size will change at abrupt media break points. This can sometimes lead to the font looking like its ‘jumping’ when it is changing size.<br>However using fluid font scaling, we look to achieve a pixel perfect *fluid scaling.<br><br>We can use fluid font scaling to handle mobile devices and desktop devices separately. This will mean we can provide a better overall user experience.<br>A lot can change from 300 to 3000px, and we should account for that.<br><br>In our css file, we can set our font size based on the calc() method.<br><br><img class='blog-image small' src='images/fluidfont.png'><br><br>We evaluate the page width and the preferred maximum and minimum size of the font.<br>The browser will compute the value based on each pixel change. This will have a smooth render flow that will be appreciated by users.At first this calculating may look complicated, but its really very simple and very smart code.<br><br>This can be applied to many other properties in our css file too. Have fun applying this to as many properties you think will benefit, as this will save you time and space in your media queries. <br><br>Having a fluid page not only feels cool from a user side, but it has the code saving benefits. Imagine how many sizes of font that may change over the media query change, we can solve this by applying just two - for each the desktop and mobile device.<br><br>Check out some example on code pen here I have provided below.<br><br>&#x1f517; <a href='http://codepen.io/search/pens/?limit=all&page=2&q=fluid+typography'>Codepen.io - Fluid Typography</a><br><br>&#x1f517;  <a href='https://www.smashingmagazine.com/2016/05/fluid-typography/'>Smashing Magazine - Fluid Typography</a><br><br>&#x1f517;  <a href='https://css-tricks.com/snippets/css/fluid-typography/'>CSS Tricks- Fluid Typography</a>";


fluidfontContainer.appendChild(parafluidfont);
fluidfontBlog.appendChild(fluidfontContainer);


var serviceWorkerBlog = document.getElementById('serviceWorkerBlog');
    
var mainImageSW = document.createElement('IMG');
    mainImageSW.src = 'images/theServiceWorkerIMG.png';
    mainImageSW.classList.add('blog-image');
    serviceWorkerBlog.appendChild(mainImageSW);

var serviceWorkerBlogContainer = document.createElement('DIV');
var paraServiceWorker = document.createElement('p');
paraServiceWorker.innerHTML = "<hr>&#x2606; <b>What's it all about?</b><br><br>Apart from being a dream come true for people who hate 404 or error pages.<br><br>A service worker essentially allows you to reload an internet page without connection.<br><br>The first time you load a page, a cached version of the page is stored in your history.  The next time you load the page, the reload time can essentially be cut in half, if not more. <br><br>The service worker allows for offline user experience. Another great leap forward in webapp development.<br><br>In my opinion, the service worker will be one of the starting blocks that leads to us never needing to download apps from the app store again.<br><br><b>So just how does it work?</b><br><br>The service worker completes a life-cycle. The process involves registration, installation, cache and return requests. Following any changes to the requests the service worker will update and the cycle will start again. The service worker intercepts the render and can display cached data for the user.<br><br><b>Cool, so what do I need to get started?</b><br><br>Browser compatability is growing all the time, however this is still experimental technology. If you check devtools>application>ServiceWorker, you will find service workers for many large sites including youtube and netflix. Also it is important to note that service workers will only work live with https, for testing you can use github, firebase or localhost to get started quickly.<br><br><b>Ok, sounds easy, lets go.. </b><br><br><p class='blogPadding'>1. Register your first service worker - in your main.js || app.js</p><br><br><iframe height='300' scrolling='no' title='Service worker starter' src='//codepen.io/gtolan/embed/KmRdVZ/?height=300&theme-id=19956&default-tab=js&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/gtolan/pen/KmRdVZ/'>Service worker starter</a> by Gtolan (<a href='http://codepen.io/gtolan'>@gtolan</a>) on <a href='http://codepen.io'>CodePen</a>.</iframe><br><br> This will console the current state of the service worker. If everything is running correctly this state should also available in devtools>application>serviceworker.<br><br>This registration refers to a file named swName. This file is your service worker script. This should be placed at the root of your application.<br><br><p class='blogPadding'>2. Add your service worker file - 'swNAME.js'</p><br><br> <iframe height='300' scrolling='no' title='Service worker starter 2' src='//codepen.io/gtolan/embed/gWzaMM/?height=300&theme-id=19956&default-tab=js&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/gtolan/pen/gWzaMM/'>Service worker starter 2</a> by Gtolan (<a href='http://codepen.io/gtolan'>@gtolan</a>) on <a href='http://codepen.io'>CodePen</a>.</iframe><br><br> We have just done a heck of a lot for our app, in a short amount of code. Lets talk about what just happened in the sw file. Lets take this in four steps. <br><br>1. Service worker setup - we declare our variables and dependencies for the service worker. This setup allows you tow name your caches. There will be a cache for precache waiting data, and also a cache for runtime data. We can also add more caches for different pages or sections. We declare all our precache urls that we want to add to the service worker. This involves all html, css, js and images/media we want to be available.<br><br>2. Our install event listener fires and takes care of precaching our resources.<br><br>3. The activate listener is fired and our service worker handle our cached resources. This means removing the precache and placing it as the runtime cache.<br><br>4. The fetch request intercepts the page download and instead asks for the runtime cache which will render the page.<br><br>Thats almost it, there is a lot I could talk about with gotchas and bewares, but if you plan on taking your service worker to the next level you can read further at Mozilla and Google. The final stage to complete the cycle is the update of the service worker. <br><br>The next time the browser tries to redownload the service worker script in the background. If there is even a one byte change in the resources, it will update. Your service worker will start the update process and the install event will fire. At this point the old sw is still managing the page and the new sw will be waiting in the precahce stage. The next time the browser is closed *or depending on browser settings - on refresh) The new sw will be called to render the page.<br><br>The service worker has lots of tools and fun extensions you can try experiment with. One of the main benefits to a service worker is all of the extra abilities it gives to your page. Not only as a fantastic immediate cache render. But, also in adding more progessive app like features, such as device notifications or a home screen download icon.  <br><br>&#x1f517;  <a href='https://developers.google.com/web/fundamentals/getting-started/primers/service-workers'>Google Developer - The service worker, an introduction</a><br><br>&#x1f517;  <a href='https://jakearchibald.com/2014/offline-cookbook/'>Jake Archibald(SW Guru) - Offline Cookbook,</a><br><br>&#x1f517;  <a href='https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers'>Mozilla Developers Network - Using the service worker</a><br><br>&#x1f517; <a href='https://www.udacity.com/course/offline-web-applications--ud899'>Udacity - Offline Webapp Course</a>";

serviceWorkerBlogContainer.appendChild(paraServiceWorker);
serviceWorkerBlog.appendChild(serviceWorkerBlogContainer);


fluidfontContainer.appendChild(parafluidfont);
fluidfontBlog.appendChild(fluidfontContainer);


var jsAnimationBlog = document.getElementById('jsAnimationBlog');

    var mainImageJSA = document.createElement('IMG');
    mainImageJSA.src = 'images/jsanimation.png';
    mainImageJSA.classList.add('blog-image');
    jsAnimationBlog.appendChild(mainImageJSA);

    
var jsAnimationBlogContainer = document.createElement('DIV');
var paraJSAnimationBlog = document.createElement('p');
paraJSAnimationBlog.innerHTML = "<hr>&#x2606; Does your animation lag or jump on mobile devices?<br><br>Our devices are being forced to do more very day. Here are some tips for better results:<br><br>&#9432; The most well known aid to animation performance is the GPU. The GPU will create a layer that is transformable. This is a very inexepnsive method to make an animation, as the GPU can manipulate this layer with ease. Rather than relying on the CPU to generate new pixels for every frame.<br><br>Having said that, its not smart to flood the GPU with too many layers. This can have the opposite effect.<br><br>&#9432; Choose wisely between JS and CSS animation - this means that for simple animations we most likely should use CSS, however for more control and extensive animations we should use JS. <br><br><br><br><b>CSS Animation</b> <br><br>So how would we normally animate an element? Well we can simply add a class to animate on a css transition, but this can force the device to use alot of CPU. However, if we use the transform/tranlate3d property, we can trigger the use of the device GPU.<br><br>With CSS, I prefer to use its declarative benefit as much as I can. Therefore keyframes are the best way to animate in my opinion.<br><br>Not only will this allow the browser to process the class change before the animation is triggered, but it will appear smoother for the user too.<br><br>This for me is the best way in CSS to animate.<br><br> ";
jsAnimationBlogContainer.appendChild(paraJSAnimationBlog);

var paraJSAnimationBlogCSSEmbed = document.createElement('DIV');
paraJSAnimationBlogCSSEmbed.innerHTML = "<iframe height='300' scrolling='no' title='css animation' src='//codepen.io/gtolan/embed/dWmgZa/?height=300&theme-id=19956&default-tab=css,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='http://codepen.io/gtolan/pen/dWmgZa/'>css animation</a> by Gtolan (<a href='http://codepen.io/gtolan'>@gtolan</a>) on <a href='http://codepen.io'>CodePen</a>.</iframe><br><br>";

jsAnimationBlogContainer.appendChild(paraJSAnimationBlogCSSEmbed);

var paraJSAnimationBlogTwo = document.createElement('DIV');
paraJSAnimationBlogTwo.innerHTML = "<br><br><b>Pros:</b><br><br> <p class='blogPadding'>This format is descriptive and easy to follow.<br>The GPU will be triggered Webkit wiill share the load for the keyframes</p><br><br><b>Cons:</b><br><br> <p class='blogPadding'> This method has limited capability for element manipulation. If we want to animate two dynamic animations, it is not possible in CSS. That means if we have one animation running in CSS and apply a new animation, the new animation will apply. However in JS both animations can run concurrently</p><br><br><br><hr><br><br><b>JS Animation</b><br><br>The problem with JS animation is that its slow...right?<br><br>Wrong actually, this is a misconception. Given your page setup and result needed, you can achieve just as fast if not faster animations using JS.<br><br>Here is the same animation as above, but in JS. Its very similar, if not more simple.<br><br><iframe height='300' scrolling='no' title='js animation' src='//codepen.io/gtolan/embed/gWeBRY/?height=300&theme-id=19956&default-tab=js,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='http://codepen.io/gtolan/pen/gWeBRY/'>js animation</a> by Gtolan (<a href='http://codepen.io/gtolan'>@gtolan</a>) on <a href='http://codepen.io'>CodePen</a>.</iframe><br><br>There is less code and the animation is just as fast.<br><br>To keep cleaner JS we can use CSS for smaller animations. The extra beneift the JS api has is that it can control playstate. This means we can control if the animation is paused, finished, or the current position. With CSS animation we cannot pause and reverse an animation * without adding a lot of setInterval tracking.<br><br>This means that for control of animations it is better to use JS.<br><br><b>Pros:</b><br><br> <p class='blogPadding'>JS is just as fast as CSS and faster in some environments<br><br>JS can control the playstate and rewind an animation from a paused position.<br><br>For larger animations JS can be used to control more elements.</p><br><br><b>Cons:</b><br><br> <p class='blogPadding'>Using Jquery or libraries to animte can slow down animation to up to 20x.<br><br>Crowding JS with design animations</p><br><br>Most of the decision will come down to the amount of code needed to generate the animation. Both methods have strong pros, however for usability, I like to keep smaller animations in my CSS file. However to build a animated container of elements or a video like animation, I would rely on JS to perform better. I hope this helps in your animation!<br><br><br>&#x1f517; <a href='https://css-tricks.com/myth-busting-css-animations-vs-javascript/'>CSS Tricks - Myth Busting CSS v JS animation</a><br><br>&#x1f517;  <a href='https://developer.mozilla.org/en/docs/Web/API/Animation'>Mozila Developer network - JS animate api</a><br><br>&#x1f517;  <a href='https://css-tricks.com/controlling-css-animations-transitions-javascript/'>CSS Tricks- JS animation api</a>";
jsAnimationBlogContainer.appendChild(paraJSAnimationBlogTwo);

jsAnimationBlog.appendChild(jsAnimationBlogContainer);

    
}, false);
